import 'dart:async';
import 'package:build/build.dart';
import 'package:glob/glob.dart';
import 'package:meta/meta.dart';
import 'package:path/path.dart' as path;
import 'package:source_gen/source_gen.dart' show LibraryReader;

import '../errors/builder_error.dart';
import '../generators/merging_generator.dart';
import 'formatter.dart';
import 'synthetic_builder.dart';
import 'synthetic_input.dart';

/// Builder that merges its output into one file.
///
/// - Input files must be specified using [Glob] syntax.
///
/// - Requires a generator extending [MergingGenerator<T, A>].
class MergingBuilder<T, S extends SyntheticInput> extends SyntheticBuilder<S> {
  /// Constructs a [MergingBuilder] object.
  ///
  /// - [inputFiles] defaults to: `'lib/*.dart'`.
  ///
  /// - [outputFile] defaults to: `'lib/merged_output.dart'`.
  ///
  /// - [generator] extending [MergingGenerator<T, A>] is required.
  ///
  /// - [header] defaults to: `''`
  ///
  /// - [footer] defaults to : `''`
  ///
  /// - [formatOutput] defaults to: `DartFormatter().format`.
  MergingBuilder({
    String inputFiles = 'lib/*.dart',
    this.outputFile = 'lib/merged_output.dart',
    @required this.generator,
    String header = '',
    String footer = '',
    this.sortAssets = false,
    Formatter formatOutput,
  }) : super(
          inputFiles: inputFiles,
          header: header,
          footer: footer,
          formatOutput: formatOutput,
        );

  /// Path to output file relative to the package root directory.
  /// Example: `lib/merged_output.dart`
  final String outputFile;

  /// Class extending [MergingGenerator<T,A>].
  final MergingGenerator<T, dynamic> generator;

  /// Set to true to have assets sorted in reverse topological order of
  /// dependency. If a file B includes a file A, then A will be appear
  /// before B.
  ///
  /// Defaults to false;
  ///
  /// Note: A [BuilderError] is thrown if [sortAssets] is `true` and
  /// a dependency cycle is detected (e.g. File A depends on file B, and
  /// file B depends on A, even indirectly).
  final bool sortAssets;

  /// Returns the output file name.
  String get outputPath => path.basename(outputFile);

  /// Returns the output directory name.
  String get outputDirectory => path.dirname(outputFile);

  @override
  Map<String, List<String>> get buildExtensions => {
        syntheticInput.value: [outputFile]
      };

  /// Writes the merged content to the stand-alone file
  /// specified by [outputFile].
  @override
  FutureOr<void> build(BuildStep buildStep) async {
    // Validate synthetic input/output.
    SyntheticInput.validatePath<S>(inputFiles);
    SyntheticInput.validatePath<S>(outputFile);

    final List<AssetId> libraryAssetIds = (this.sortAssets)
        ? await this.orderedLibraryAssetIds(buildStep)
        : await this.libraryAssetIds(buildStep);

    // Check if output overwrites input.
    for (final libraryAssetId in libraryAssetIds) {
      if (path.equals(outputFile, libraryAssetId.path)) {
        throw BuilderError(
            message: 'Output file clashes with input file!',
            expectedState: 'Output files must not overwrite input files. '
                'Check the [MergingBuilder] constructor argument [outputFile].',
            invalidState: 'Output: $outputFile is also an input file.');
      }
    }

    await buildStep.writeAsString(
      AssetId(
        buildStep.inputId.package,
        this.outputFile,
      ),
      arrangeContent(
        await generator.generateMergedContent(
          this._combineStreams(buildStep, libraryAssetIds),
        ),
        generatedBy: 'Generated by ${generator.runtimeType}.',
      ),
    );
  }

  /// Returns a stream of objects of type [T]. Combines the streams
  /// generated by [generator.generateStream]
  /// by iterating over each library file asset.
  Stream<T> _combineStreams(
    BuildStep buildStep,
    List<AssetId> libraryAssetIds,
  ) async* {
    // Accessing libraries.
    for (final libraryAssetId in libraryAssetIds) {
      final library = LibraryReader(
        await buildStep.resolver.libraryFor(libraryAssetId),
      );

      // Calling generator.generateStream. An object of type [T] is
      // emitted for each class defined in library that is annotated with [A].
      log.fine('Running ${generator.runtimeType} on: ${libraryAssetId.path}.');
      Stream<T> streamOfT = await generator.generateStream(library, buildStep);

      // Combining all objects of type [T] into a stream.
      await for (final T t in streamOfT) {
        yield t;
      }
    }
  }
}
