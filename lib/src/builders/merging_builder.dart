import 'dart:async';

import 'package:build/build.dart';
import 'package:dart_style/dart_style.dart';
import 'package:directed_graph/directed_graph.dart';
import 'package:glob/glob.dart';
import 'package:merging_builder/merging_builder.dart';
import 'package:merging_builder/src/errors/builder_error.dart';
import 'package:path/path.dart' as path;
import 'package:source_gen/source_gen.dart' show Generator, LibraryReader;

/// Builder that merges its output into one library file.
/// Input files are to be specified using [Glob] syntax.
class MergingBuilder<T> implements Builder {
  /// Constructs a [MergingBuilder] object.
  MergingBuilder({
    this.inputFiles = 'lib/*.dart',
    this.outputFile = 'lib/merged_output.dart',
    this.generator,
    this.header = '',
    this.footer = '',
    this.formatOutput = true,
  });

  /// Input files. Specify the complete path relative to the
  /// root directory.
  ///
  /// For example: `lib/*.dart` includes all Dart files in
  /// the projects `lib` directory.
  final String inputFiles;

  /// Path to output file relative to the package root directory.
  /// Example: `lib/merged_output.dart`
  final String outputFile;

  /// Class extending [Generator] from the package [source_gen].
  final MergingGenerator generator;

  /// String that will be inserted at the top of the
  /// generated file.
  final String header;

  /// String that will be inserted at the very bottom of the
  /// generated file.
  final String footer;

  /// Set to true to enable formatting of the builder output
  /// before it is written to the output file.
  final bool formatOutput;

  /// Returns the output file name.
  String get outputFileName => path.basename(outputFile);

  /// Returns the output directory name.
  String get outputDirectoryName => path.dirname(outputFile);

  /// Returns the input file name(s).
  String get inputFileNames => path.basename(inputFiles);

  /// Returns the input file directory.
  String get inputDirectory => path.dirname(inputFiles);

  @override
  Future build(BuildStep buildStep) async {
    await buildStep.writeAsString(
      AssetId(
        buildStep.inputId.package,
        this.outputFile,
      ),
      _mergedContent(buildStep),
    );
  }

  @override
  Map<String, List<String>> get buildExtensions => {
        //r'$lib$': ['*.dart']
        r'$lib$': [this.outputFileName]
      };

  /// Returns the merged output after running [generator] on all
  /// matching input files.
  Future<String> _mergedContent(BuildStep buildStep) async {
    // Could be null if there is a circular dependency!
    final libAssetIds = await orderedAssetIds(buildStep);

    if (libAssetIds == null) {
      throw BuilderError(
          message: 'Circular dependency detected. Check the import statements'
              'of ${Glob(this.inputFiles)}');
    }

    // Add header to buffer.
    // Expand header:
    final _header = '// GENERATED CODE. DO NOT MODIFY. '
            'Generated by ${generator.runtimeType}. ${DateTime.now()}.\n\n' +
        header;
    final buffer = StringBuffer(_header);

    // Stream of type [P].
    Stream<T> stream;
    buffer.writeln();

    // Accessing libraries
    for (final libAssetId in libAssetIds) {
      // Get library.
      final library =
          LibraryReader(await buildStep.resolver.libraryFor(libAssetId));

      // Calling generator
      log.fine('Running ${generator.runtimeType} on: ${libAssetId.path}.');
      generator.generateStream<T>(library, buildStep);
    }

    final source = await generator.mergedContent(stream);
    source.trim();
    buffer.writeln(source);
    buffer.writeln();
    buffer.writeln(this.footer);

    return this.formatOutput
        ? DartFormatter().format(buffer.toString())
        : buffer.toString();
  }

  /// Returns a list of library asset Ids ordered in reverse topological
  /// dependency order.
  ///
  /// Returns [null] if a dependency cycle is detected.
  Future<List<AssetId>> orderedAssetIds(BuildStep buildStep) async {
    // Find matching input files.
    final Stream<AssetId> inputs = await buildStep.findAssets(
      Glob(this.inputFiles),
    );
    // An assetId map with the [String] uri as key.
    final Map<String, AssetId> assetMap = {};

    // Access libraries
    await for (final input in inputs) {
      // Check if input file is a library.
      bool isLibrary = await buildStep.resolver.isLibrary(input);
      if (!isLibrary) continue;
      assetMap['${input.uri}'] = input;
    }

    final Map<AssetId, Vertex<AssetId>> vertices = {};
    final assetGraph = DirectedGraph<AssetId>({},
        comparator: ((v1, v2) => -v1.data.compareTo(v2.data)));

    for (final libId in assetMap.values) {
      // Add current assetId to map of vertices:
      vertices[libId] ??= Vertex<AssetId>(libId);
      // Retrieve library.
      final library = await buildStep.resolver.libraryFor(libId);
      // Get dependencies
      final List<Vertex<AssetId>> edgeVertices = [];

      for (var import in library.imports) {
        // Dart core libraries have uri null.
        if (import.uri == null) continue;
        final importedAssetId = assetMap[import.uri];
        // Continue if import does not refer to a file in [this.inputFiles].
        if (importedAssetId == null) continue;

        //final asset = await AssetId.resolve(import.uri);
        //print(asset == assetMap[import.uri]);

        // Add vertex of importedAssetId if it does not exist yet.
        vertices[importedAssetId] ??= Vertex<AssetId>(importedAssetId);
        edgeVertices.add(vertices[importedAssetId]);
      }
      assetGraph.addEdges(vertices[libId], edgeVertices);
    }

    return assetGraph
        .topologicalOrdering()
        ?.reversed
        ?.expand<AssetId>((item) => [item.data])
        ?.toList();
  }
}
