import 'package:dart_style/dart_style.dart';
import 'package:merging_builder/merging_builder.dart';
import 'package:source_gen/source_gen.dart';

/// Mock builder with methods: [mergedContent] and [_combinedStream].
/// Used for testing purposes.
class MockMergingBuilder<T> {
  MockMergingBuilder({
    this.generator,
    this.header,
    this.footer,
    this.libraries,
    Formatter formatOutput,
  }) : this._formatOutput = formatOutput ?? DartFormatter().format;

  final MergingGenerator<T, dynamic> generator;
  final String header;
  final String footer;
  final Formatter _formatOutput;
  final List<LibraryReader> libraries;

  /// Returns the merged [Future<String>] output. Calls the
  /// generator method: [generator.mergedContent(_combinedStream(buildStep))].
  Future<String> get mergedContent async {
    // Add header to buffer.
    // Expand header:
    final _header = '// GENERATED CODE. DO NOT MODIFY. '
            'Generated by ${generator.runtimeType}. \n\n' +
        header;
    final buffer = StringBuffer(_header);
    buffer.writeln();

    // Call generator function responsible for creating merged content.
    final source =
        await generator.generateMergedContent(this._combineStreams());
    source.trim();
    buffer.writeln(source);
    buffer.writeln();

    // Add footer.
    if (this.footer != null) buffer.writeln(this.footer);

    // Format output.
    return _formatOutput(buffer.toString());
  }

  /// Generates a stream of objects of type [T]. Combines the streams
  /// generated by [generator.generateStream(library, buildStep)]
  /// by iterating over each file asset.
  Stream<T> _combineStreams() async* {
    for (final library in libraries) {
      Stream<T> streamOfT = await generator.generateStream(library, null);
      // Combining all objects of type [T] into a stream.
      await for (final T t in streamOfT) {
        yield t;
      }
    }
  }
}
