import 'package:crypto/src/digest.dart';
import 'package:build/src/resource/resource.dart';
import 'package:build/src/asset/id.dart';
import 'package:build/src/analyzer/resolver.dart';
import 'package:analyzer/dart/element/element.dart';
import 'dart:convert';

import 'dart:async';

import 'package:dart_style/dart_style.dart';
import 'package:glob/glob.dart';
import 'package:merging_builder/merging_builder.dart';
import 'package:merging_builder/src/builders/formatter.dart';
import 'package:source_gen/source_gen.dart';
import 'package:build/build.dart' show BuildStep;

/// Mock builder with methods: [mergedContent] and [_combinedStream].
/// Used for testing purposes.
class MockMergingBuilder<T> {
  MockMergingBuilder({
    required this.generator,
    this.header = '',
    this.footer = '',
    required this.libraries,
    Formatter? formatOutput,
  }) : _formatOutput = formatOutput ?? DartFormatter().format;

  final MergingGenerator<T, dynamic> generator;
  final String header;
  final String footer;
  final Formatter _formatOutput;
  final List<LibraryReader> libraries;

  /// Returns the merged [Future<String>] output. Calls the
  /// generator method: [generator.mergedContent(_combinedStream(buildStep))].
  Future<String> get mergedContent async {
    // Add header to buffer.
    // Expand header:
    final _header = '// GENERATED CODE. DO NOT MODIFY. '
            'Generated by ${generator.runtimeType}. \n\n' +
        header;
    final buffer = StringBuffer(_header);
    buffer.writeln();

    // Call generator function responsible for creating merged content.
    final source = await generator.generateMergedContent(_combineStreams());
    source.trim();
    buffer.writeln(source);
    buffer.writeln();

    // Add footer.
    buffer.writeln(footer);

    // Format output.
    return _formatOutput(buffer.toString());
  }

  /// Generates a stream of objects of type [T]. Combines the streams
  /// generated by [generator.generateStream(library, buildStep)]
  /// by iterating over each file asset.
  Stream<T> _combineStreams() async* {
    for (final library in libraries) {
      final streamOfT = generator.generateStream(library, MockBuildStep());
      // Combining all objects of type [T] into a stream.
      await for (final T t in streamOfT) {
        yield t;
      }
    }
  }
}

class MockBuildStep extends BuildStep {
  @override
  Future<bool> canRead(AssetId id) {
    // TODO: implement canRead
    throw UnimplementedError();
  }

  @override
  Future<Digest> digest(AssetId id) {
    // TODO: implement digest
    throw UnimplementedError();
  }

  @override
  Future<T> fetchResource<T>(Resource<T> resource) {
    // TODO: implement fetchResource
    throw UnimplementedError();
  }

  @override
  Stream<AssetId> findAssets(Glob glob) {
    // TODO: implement findAssets
    throw UnimplementedError();
  }

  @override
  // TODO: implement inputId
  AssetId get inputId => throw UnimplementedError();

  @override
  // TODO: implement inputLibrary
  Future<LibraryElement> get inputLibrary => throw UnimplementedError();

  @override
  Future<List<int>> readAsBytes(AssetId id) {
    // TODO: implement readAsBytes
    throw UnimplementedError();
  }

  @override
  Future<String> readAsString(AssetId id, {Encoding encoding = utf8}) {
    // TODO: implement readAsString
    throw UnimplementedError();
  }

  @override
  void reportUnusedAssets(Iterable<AssetId> ids) {
    // TODO: implement reportUnusedAssets
  }

  @override
  // TODO: implement resolver
  Resolver get resolver => throw UnimplementedError();

  @override
  T trackStage<T>(String label, T Function() action,
      {bool isExternal = false}) {
    // TODO: implement trackStage
    throw UnimplementedError();
  }

  @override
  Future<void> writeAsBytes(AssetId id, FutureOr<List<int>> bytes) {
    // TODO: implement writeAsBytes
    throw UnimplementedError();
  }

  @override
  Future<void> writeAsString(AssetId id, FutureOr<String> contents,
      {Encoding encoding = utf8}) {
    // TODO: implement writeAsString
    throw UnimplementedError();
  }
}
